<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>纸上飞机大战</title>
  <style>
    :root {
      --paper-bg: #f7f7f5;
      --grid-line: rgba(0,0,0,0.08);
      --grid-bold: rgba(0,0,0,0.12);
      --text: #333;
      --red: #e74c3c;
      --blue: #3498db;
      --ink: rgba(0,0,0,0.85);
      --panel-bg: rgba(255,255,255,0.92);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #dedede;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Helvetica Neue", "Noto Sans SC", "PingFang SC", "Microsoft YaHei", Arial, sans-serif;
      color: var(--text);
    }
    .app {
      width: min(92vw, 1000px);
      aspect-ratio: 4 / 3;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      gap: 8px;
      user-select: none;
    }
    .hud {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
    }
    .title {
      font-weight: 800;
      letter-spacing: 0.5px;
      text-shadow: 0 1px 0 rgba(255,255,255,0.6);
    }
    .turn {
      padding: 6px 10px;
      border-radius: 8px;
      background: rgba(255,255,255,0.7);
      box-shadow: 0 1px 2px rgba(0,0,0,0.08);
    }
    .legend { opacity: 0.7; }
    .canvas-wrap {
      position: relative;
      flex: 1;
      width: 100%;
      border-radius: 10px;
      box-shadow: 0 8px 25px rgba(0,0,0,0.15);
      overflow: hidden;
      background: var(--paper-bg);
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: transparent;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
      font-weight: 800;
      font-size: clamp(20px, 4vw, 42px);
      color: rgba(0,0,0,0.75);
      text-shadow: 0 2px 0 rgba(255,255,255,0.7);
    }
    .ui-layer {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: auto;
    }
    .panel {
      min-width: 60%;
      max-width: 80%;
      padding: 20px 24px;
      border-radius: 12px;
      background: var(--panel-bg);
      box-shadow: 0 8px 25px rgba(0,0,0,0.2);
      border: 1.5px dashed rgba(0,0,0,0.15);
      text-align: center;
    }
    .panel h1 { margin: 8px 0 0; font-size: 26px; }
    .panel p { margin: 8px 0 12px; opacity: 0.8; }
    .btns { display: flex; gap: 12px; justify-content: center; }
    .btn {
      appearance: none;
      padding: 10px 18px;
      border-radius: 10px;
      border: 2px solid #333;
      background: #fff;
      box-shadow: 3px 3px 0 #333;
      cursor: pointer;
      font-weight: 800;
      transition: transform 0.06s ease, box-shadow 0.06s ease;
    }
    .btn:hover { transform: translate(-1px, -1px); box-shadow: 4px 4px 0 #333; }
    .btn:active { transform: translate(1px, 1px); box-shadow: 2px 2px 0 #333; }
    .btn.primary { border-color: var(--blue); box-shadow: 3px 3px 0 var(--blue); }
    .btn.danger { border-color: var(--red); box-shadow: 3px 3px 0 var(--red); }
  </style>
</head>
<body>
  <div class="app">
    <div class="hud">
      <div class="title">纸上飞机大战</div>
      <div id="turn" class="turn">红方回合</div>
      <div class="legend">操作：按住己方飞机，快速甩动并松开</div>
    </div>
    <div class="canvas-wrap">
      <canvas id="game"></canvas>
      <div id="overlay" class="overlay" style="display:none"></div>
      <div id="ui" class="ui-layer">
        <div id="menuPanel" class="panel">
          <h1>纸上飞机大战</h1>
          <p>双人回合制 · 手绘涂鸦风 · 甩动鼠标发起进攻</p>
          <div class="btns">
            <button id="startBtn" class="btn primary">开始游戏</button>
          </div>
        </div>
        <div id="gameOverPanel" class="panel" style="display:none">
          <h1 id="gameOverTitle">游戏结束</h1>
          <p id="gameOverMsg">红蓝双方已分出胜负</p>
          <div class="btns">
            <button id="restartBtn" class="btn danger">重新开始</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ========== 基本设置 ==========
    const CANVAS_BASE_W = 960; // 逻辑宽度（4:3）
    const CANVAS_BASE_H = 720; // 逻辑高度（4:3）
    const GRID = 36;           // 网格间距
    const FRICTION = 0.95;     // 速度摩擦（每帧）
    const MIN_SPEED = 0.6;     // 停止阈值（像素/帧）
    const MAX_INIT_SPEED = 28; // 初始速度上限（像素/帧）
    const SELECT_HALO = 10;    // 选择容差

    const canvas = document.getElementById('game');
    const overlay = document.getElementById('overlay');
    const uiLayer = document.getElementById('ui');
    const menuPanel = document.getElementById('menuPanel');
    const gameOverPanel = document.getElementById('gameOverPanel');
    const gameOverTitle = document.getElementById('gameOverTitle');
    const gameOverMsg = document.getElementById('gameOverMsg');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const turnEl = document.getElementById('turn');
    const ctx = canvas.getContext('2d');

    let DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    let viewW = CANVAS_BASE_W;
    let viewH = CANVAS_BASE_H;
    let SCALE_X = 1, SCALE_Y = 1;

    function resizeCanvas() {
      const rect = canvas.parentElement.getBoundingClientRect();
      viewW = Math.round(rect.width);
      viewH = Math.round(rect.height);
      DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
      SCALE_X = viewW / CANVAS_BASE_W;
      SCALE_Y = viewH / CANVAS_BASE_H;
      canvas.width = viewW * DPR;
      canvas.height = viewH * DPR;
      ctx.setTransform(DPR * SCALE_X, 0, 0, DPR * SCALE_Y, 0, 0);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ========== 游戏状态 ==========
    const state = {
      gamePhase: 'menu', // menu | playing | gameover
      currentPlayer: 0,  // 0: 红方, 1: 蓝方
      gameOver: false,
      strokes: [],     // 纸上保留的所有笔迹
      effects: [],     // 动画特效（溅射/爆炸等）
      flick: null,     // 当前滑行动画对象
      turnCue: null,   // 回合切换提示
      planes: [[], []] // 双方飞机
    };

    // 飞机定义
    function createPlane(x, y, color, orientation) {
      const heading = orientation === 'right' ? 0 : Math.PI;
      return {
        x, y,
        size: 28,
        color,
        orientation, // 'right' or 'left'
        heading,     // 朝向（弧度）
        alive: true,
        alpha: 1
      };
    }

    function initPlanes() {
      state.planes[0] = []; state.planes[1] = [];
      const margin = 60;
      const spacing = (CANVAS_BASE_H - margin * 2) / 5; // 平均分 5 段
      // 红方（左）
      for (let i = 0; i < 5; i++) {
        const y = margin + spacing * (i + 0.5);
        state.planes[0].push(createPlane(90, y, '#e74c3c', 'right'));
      }
      // 蓝方（右）
      for (let i = 0; i < 5; i++) {
        const y = margin + spacing * (i + 0.5);
        state.planes[1].push(createPlane(CANVAS_BASE_W - 90, y, '#3498db', 'left'));
      }
    }

    // ========== 纸张背景绘制（格纹 + 噪点 + 边缘阴影） ==========
    function drawPaperBackground() {
      // 背景底色
      ctx.fillStyle = '#f7f7f5';
      ctx.fillRect(0, 0, CANVAS_BASE_W, CANVAS_BASE_H);

      // 纸张边缘阴影
      const grad = ctx.createLinearGradient(0, 0, 0, CANVAS_BASE_H);
      grad.addColorStop(0, 'rgba(0,0,0,0.06)');
      grad.addColorStop(0.04, 'rgba(0,0,0,0)');
      grad.addColorStop(0.96, 'rgba(0,0,0,0)');
      grad.addColorStop(1, 'rgba(0,0,0,0.06)');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, CANVAS_BASE_W, CANVAS_BASE_H);

      // 轻微纸纹噪点
      const noiseCount = Math.floor((CANVAS_BASE_W * CANVAS_BASE_H * SCALE_X * SCALE_Y) / 1600);
      ctx.globalAlpha = 0.045;
      ctx.fillStyle = '#000';
      for (let i = 0; i < noiseCount; i++) {
        const x = Math.random() * CANVAS_BASE_W;
        const y = Math.random() * CANVAS_BASE_H;
        const r = Math.random() * 1.2 + 0.2;
        ctx.fillRect(x, y, r, r);
      }
      ctx.globalAlpha = 1;

      // 竖/横细格
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(0,0,0,0.09)';
      ctx.beginPath();
      for (let x = 0; x <= CANVAS_BASE_W; x += GRID) {
        ctx.moveTo(x + 0.5, 0);
        ctx.lineTo(x + 0.5, CANVAS_BASE_H);
      }
      for (let y = 0; y <= CANVAS_BASE_H; y += GRID) {
        ctx.moveTo(0, y + 0.5);
        ctx.lineTo(CANVAS_BASE_W, y + 0.5);
      }
      ctx.stroke();

      // 加粗辅助线（每 5 格）
      ctx.strokeStyle = 'rgba(0,0,0,0.12)';
      ctx.beginPath();
      for (let x = 0; x <= CANVAS_BASE_W; x += GRID * 5) {
        ctx.moveTo(x + 0.5, 0);
        ctx.lineTo(x + 0.5, CANVAS_BASE_H);
      }
      for (let y = 0; y <= CANVAS_BASE_H; y += GRID * 5) {
        ctx.moveTo(0, y + 0.5);
        ctx.lineTo(CANVAS_BASE_W, y + 0.5);
      }
      ctx.stroke();
    }

    // ========== 几何工具（考虑旋转） ==========
    function getTriangleVertices(plane) {
      const s = plane.size;
      // 局部顶点（默认指向右）
      const local = [
        { x: s, y: 0 },
        { x: -s, y: -s * 0.7 },
        { x: -s, y: s * 0.7 }
      ];
      const c = Math.cos(plane.heading), d = Math.sin(plane.heading);
      return local.map(v => ({ x: plane.x + v.x * c - v.y * d, y: plane.y + v.x * d + v.y * c }));
    }

    function pointInTriangle(p, tri) {
      const [a, b, c] = tri;
      const area = (v1, v2, v3) => (
        (v2.x - v1.x) * (v3.y - v1.y) - (v3.x - v1.x) * (v2.y - v1.y)
      );
      const b1 = area(p, a, b) < 0;
      const b2 = area(p, b, c) < 0;
      const b3 = area(p, c, a) < 0;
      return (b1 === b2) && (b2 === b3);
    }

    function segIntersect(p1, p2, q1, q2) {
      const d = (p, q, r) => ((q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x));
      const onSeg = (p, q, r) => (Math.min(p.x, r.x) <= q.x + 1e-6 && q.x <= Math.max(p.x, r.x) + 1e-6 &&
                                  Math.min(p.y, r.y) <= q.y + 1e-6 && q.y <= Math.max(p.y, r.y) + 1e-6);
      const d1 = d(p1, p2, q1);
      const d2 = d(p1, p2, q2);
      const d3 = d(q1, q2, p1);
      const d4 = d(q1, q2, p2);
      if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) && ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) return true;
      if (Math.abs(d1) < 1e-6 && onSeg(p1, q1, p2)) return true;
      if (Math.abs(d2) < 1e-6 && onSeg(p1, q2, p2)) return true;
      if (Math.abs(d3) < 1e-6 && onSeg(q1, p1, q2)) return true;
      if (Math.abs(d4) < 1e-6 && onSeg(q1, p2, q2)) return true;
      return false;
    }

    function segmentTriangleIntersect(a, b, tri) {
      if (pointInTriangle(a, tri) || pointInTriangle(b, tri)) return true;
      return segIntersect(a, b, tri[0], tri[1]) ||
             segIntersect(a, b, tri[1], tri[2]) ||
             segIntersect(a, b, tri[2], tri[0]);
    }

    // ========== 绘制：飞机（涂鸦风 + 旋转） ==========
    function drawPlane(plane) {
      ctx.save();
      ctx.translate(plane.x, plane.y);
      ctx.rotate(plane.heading);
      ctx.globalAlpha = plane.alpha;

      const s = plane.size;
      // 机体三角形
      ctx.beginPath();
      ctx.moveTo(s, 0);
      ctx.lineTo(-s, -s * 0.7);
      ctx.lineTo(-s, s * 0.7);
      ctx.closePath();
      ctx.lineWidth = 2.4;
      ctx.strokeStyle = plane.color;
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fill();
      ctx.stroke();

      // 手绘质感噪点
      ctx.globalAlpha = 0.06 * plane.alpha;
      for (let i = 0; i < 40; i++) {
        const rx = (Math.random() - 0.5) * s * 0.8;
        const ry = (Math.random() - 0.5) * s * 0.8;
        ctx.beginPath();
        ctx.arc(rx, ry, Math.random() * 2.0 + 0.4, 0, Math.PI * 2);
        ctx.fillStyle = '#000';
        ctx.fill();
      }
      ctx.globalAlpha = plane.alpha;

      // 机翼/折痕（涂鸦线）
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = 'rgba(0,0,0,0.5)';
      ctx.beginPath();
      ctx.moveTo(-s * 0.2, -s * 0.5);
      ctx.lineTo(s * 0.4, 0);
      ctx.moveTo(-s * 0.2, s * 0.5);
      ctx.lineTo(s * 0.4, 0);
      ctx.stroke();

      ctx.restore();
    }

    function drawStroke(points) {
      if (!points || points.length < 2) return;
      const layers = 3;
      for (let l = 0; l < layers; l++) {
        ctx.beginPath();
        for (let i = 0; i < points.length; i++) {
          const jitter = (Math.random() - 0.5) * (l === 0 ? 0.6 : 1.2);
          const x = points[i].x + jitter;
          const y = points[i].y + jitter;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.lineWidth = 1.8 + l * 0.6;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        ctx.strokeStyle = `rgba(0,0,0,${0.22 + l * 0.14})`;
        ctx.stroke();
      }
    }

    // 飞行速度线（速度感特效）
    function drawSpeedLines(pos, vel) {
      const speed = Math.hypot(vel.x, vel.y);
      if (speed < 2) return;
      const dir = Math.atan2(vel.y, vel.x);
      const back = dir + Math.PI; // 反向
      const count = Math.min(12, Math.floor(speed));
      ctx.save();
      for (let i = 0; i < count; i++) {
        const len = 6 + Math.random() * speed * 0.6;
        const spread = (Math.random() - 0.5) * 0.6;
        const angle = back + spread;
        const x2 = pos.x + Math.cos(angle) * len;
        const y2 = pos.y + Math.sin(angle) * len;
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
        ctx.lineTo(x2, y2);
        ctx.lineWidth = 1 + Math.random() * 1.4;
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.stroke();
      }
      ctx.restore();
    }

    // 特效：溅射 + 爆炸
    function drawEffects() {
      for (const e of state.effects) {
        if (e.type === 'splatter') {
          const count = 22;
          for (let i = 0; i < count; i++) {
            const ang = Math.random() * Math.PI * 2;
            const dist = Math.random() * e.radius;
            const x = e.x + Math.cos(ang) * dist;
            const y = e.y + Math.sin(ang) * dist;
            ctx.globalAlpha = e.alpha * (0.6 + Math.random() * 0.4);
            ctx.fillStyle = e.color;
            ctx.beginPath();
            ctx.arc(x, y, Math.random() * 3 + 0.8, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.globalAlpha = 1;
        } else if (e.type === 'explosion') {
          // 扩散圆环
          ctx.save();
          ctx.globalAlpha = e.alpha;
          ctx.lineWidth = 2;
          ctx.strokeStyle = e.color;
          ctx.beginPath();
          ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
          ctx.stroke();
          // 碎片（纸片线段）
          for (const sh of e.shards) {
            const x1 = e.x + Math.cos(sh.angle) * sh.pos;
            const y1 = e.y + Math.sin(sh.angle) * sh.pos;
            const x2 = x1 + Math.cos(sh.angle) * sh.len;
            const y2 = y1 + Math.sin(sh.angle) * sh.len;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineWidth = 1.6;
            ctx.strokeStyle = 'rgba(0,0,0,0.6)';
            ctx.stroke();
            // 更新碎片位置
            sh.pos += sh.speed;
            sh.len *= 0.98;
          }
          ctx.restore();
          // 生命周期更新
          e.radius += 2.2;
          e.alpha -= 0.035;
        }
      }
      // 清理
      state.effects = state.effects.filter(e => e.alpha > 0);
    }

    // 选中提示：按住己方飞机时显示环形提示
    function drawSelection(plane) {
      ctx.save();
      const t = performance.now();
      const pulse = (Math.sin(t / 180) + 1) * 0.5;
      const r = plane.size + 12 + pulse * 4;
      ctx.lineWidth = 2.5;
      ctx.strokeStyle = plane.color;
      ctx.globalAlpha = 0.5;
      ctx.setLineDash([8, 6]);
      ctx.beginPath();
      ctx.arc(plane.x, plane.y, r, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.globalAlpha = 0.25;
      ctx.beginPath();
      ctx.arc(plane.x, plane.y, r - 3, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    // 回合切换提示条
    function drawTurnCue() {
      const cue = state.turnCue;
      if (!cue) return;
      const w = 240, h = 40;
      const x = CANVAS_BASE_W / 2 - w / 2;
      const y = 14;
      ctx.save();
      ctx.globalAlpha = Math.max(0, cue.alpha);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.strokeStyle = cue.color;
      ctx.lineWidth = 2;
      const r = 10;
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = cue.color;
      ctx.font = 'bold 20px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(cue.text, x + w / 2, y + h / 2);
      ctx.restore();
      cue.life -= 1;
      cue.alpha = cue.life / 60;
      if (cue.life <= 0) state.turnCue = null;
    }

    // ========== 输入与交互 ==========
    let pointerDown = false;
    let selectedPlane = null;
    let trace = []; // 最近的鼠标轨迹（用于速度计算）

    function canvasToLocal(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left) / SCALE_X,
        y: (e.clientY - rect.top) / SCALE_Y
      };
    }

    function isPlaneSelectable(plane) {
      return plane.alive && ((state.currentPlayer === 0 && plane.color === '#e74c3c') || (state.currentPlayer === 1 && plane.color === '#3498db'));
    }

    function pickPlaneAt(x, y) {
      const side = state.currentPlayer;
      for (const plane of state.planes[side]) {
        if (!isPlaneSelectable(plane)) continue;
        const tri = getTriangleVertices(plane);
        if (pointInTriangle({ x, y }, tri)) return plane;
        const dx = x - plane.x, dy = y - plane.y;
        if (Math.hypot(dx, dy) < plane.size + SELECT_HALO) return plane;
      }
      return null;
    }

    canvas.addEventListener('mousedown', (e) => {
      if (state.gamePhase !== 'playing' || state.gameOver || state.flick) return;
      pointerDown = true;
      trace = [];
      const p = canvasToLocal(e);
      selectedPlane = pickPlaneAt(p.x, p.y);
      if (selectedPlane) {
        canvas.style.cursor = 'grabbing';
        trace.push({ x: p.x, y: p.y, t: performance.now() });
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!pointerDown || !selectedPlane) return;
      const p = canvasToLocal(e);
      const now = performance.now();
      trace.push({ x: p.x, y: p.y, t: now });
      while (trace.length && now - trace[0].t > 150) trace.shift();
    });

    function clampToCanvas(pt) {
      return { x: Math.max(6, Math.min(CANVAS_BASE_W - 6, pt.x)), y: Math.max(6, Math.min(CANVAS_BASE_H - 6, pt.y)) };
    }

    canvas.addEventListener('mouseup', (e) => {
      if (!pointerDown) return;
      pointerDown = false;
      canvas.style.cursor = 'crosshair';
      if (!selectedPlane) return;

      // 计算释放瞬间速度向量：使用最近 ~80ms 与最后点差值
      if (trace.length < 2) { selectedPlane = null; return; }
      const last = trace[trace.length - 1];
      let refIdx = trace.length - 1;
      while (refIdx > 0 && (last.t - trace[refIdx - 1].t) < 80) refIdx--;
      const ref = trace[refIdx];
      const dt = Math.max(1, last.t - ref.t);
      let vx_ms = (last.x - ref.x) / dt;
      let vy_ms = (last.y - ref.y) / dt;
      let vx = vx_ms * 16;
      let vy = vy_ms * 16;
      let v0 = Math.hypot(vx, vy);
      if (v0 < 3) { selectedPlane = null; return; }
      const scale = Math.min(1, MAX_INIT_SPEED / v0);
      vx *= scale; vy *= scale; v0 *= scale;

      const start = { x: selectedPlane.x, y: selectedPlane.y };
      const points = [ { x: start.x, y: start.y } ];
      state.flick = {
        plane: selectedPlane,
        pos: { x: start.x, y: start.y },
        vel: { x: vx, y: vy },
        points,
        color: '#000'
      };
      selectedPlane = null;
    });

    canvas.addEventListener('mouseleave', () => {
      if (pointerDown) {
        pointerDown = false;
        selectedPlane = null;
        trace = [];
        canvas.style.cursor = 'crosshair';
      }
    });

    // ========== 碰撞与摧毁 ==========
    function tryHitEnemies(prev, cur, attackerSide) {
      const defenderSide = attackerSide === 0 ? 1 : 0;
      for (const enemy of state.planes[defenderSide]) {
        if (!enemy.alive) continue;
        const tri = getTriangleVertices(enemy);
        if (segmentTriangleIntersect(prev, cur, tri)) {
          enemy.alive = false;
          // 溅射 + 爆炸效果
          state.effects.push({ type: 'splatter', x: enemy.x, y: enemy.y, color: enemy.color, alpha: 1, radius: 26 });
          const shards = Array.from({ length: 16 }, () => ({ angle: Math.random() * Math.PI * 2, speed: 2 + Math.random() * 3, len: 10 + Math.random() * 12, pos: 0 }));
          state.effects.push({ type: 'explosion', x: enemy.x, y: enemy.y, color: enemy.color, alpha: 1, radius: 8, shards });
        }
      }
    }

    // ========== 回合与胜负 ==========
    function updateTurnHUD() {
      if (state.gameOver) return;
      const who = state.currentPlayer === 0 ? '红方回合' : '蓝方回合';
      turnEl.textContent = who;
      turnEl.style.border = '1px solid rgba(0,0,0,0.08)';
      turnEl.style.boxShadow = '0 2px 4px rgba(0,0,0,0.06)';
      turnEl.style.color = state.currentPlayer === 0 ? '#e74c3c' : '#3498db';
    }

    function checkWin() {
      const redAlive = state.planes[0].some(p => p.alive);
      const blueAlive = state.planes[1].some(p => p.alive);
      if (!redAlive || !blueAlive) {
        state.gameOver = true;
        state.gamePhase = 'gameover';
        const msg = !redAlive && !blueAlive ? '平局' : (!redAlive ? '蓝方胜利' : '红方胜利');
        gameOverTitle.textContent = msg;
        gameOverMsg.textContent = '点击重新开始可再战一局';
        menuPanel.style.display = 'none';
        gameOverPanel.style.display = '';
        uiLayer.style.display = 'grid';
      }
    }

    function endTurn() {
      state.currentPlayer = state.currentPlayer === 0 ? 1 : 0;
      const text = state.currentPlayer === 0 ? '红方回合' : '蓝方回合';
      const color = state.currentPlayer === 0 ? '#e74c3c' : '#3498db';
      state.turnCue = { text, color, alpha: 1, life: 60 };
      updateTurnHUD();
      checkWin();
    }

    function newGame() {
      state.gamePhase = 'playing';
      state.currentPlayer = 0;
      state.gameOver = false;
      state.strokes = [];
      state.effects = [];
      state.flick = null;
      state.turnCue = { text: '红方回合', color: '#e74c3c', alpha: 1, life: 60 };
      initPlanes();
      updateTurnHUD();
      // UI
      menuPanel.style.display = 'none';
      gameOverPanel.style.display = 'none';
      uiLayer.style.display = 'none';
    }

    startBtn.addEventListener('click', () => { newGame(); });
    restartBtn.addEventListener('click', () => { newGame(); });
    window.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'r') { newGame(); }
    });

    // ========== 主循环 ==========
    function step() {
      // 清屏 & 背景
      drawPaperBackground();
      // 回合提示
      drawTurnCue();

      // 画保留的笔迹
      for (const s of state.strokes) drawStroke(s.points);

      // 当前滑行的临时轨迹也画出
      if (state.flick) {
        drawStroke(state.flick.points);
        drawSpeedLines(state.flick.pos, state.flick.vel);
      }

      // 飞机
      for (const p of state.planes[0]) if (p.alive || p.alpha > 0) drawPlane(p);
      for (const p of state.planes[1]) if (p.alive || p.alpha > 0) drawPlane(p);

      // 选中提示（按住时）
      if (pointerDown && selectedPlane) drawSelection(selectedPlane);

      // 特效
      drawEffects();

      // 更新被摧毁飞机的淡出
      for (const side of [0,1]) {
        for (const p of state.planes[side]) {
          if (!p.alive && p.alpha > 0) p.alpha -= 0.05;
        }
      }

      // 滑行动画更新
      if (state.flick) {
        const f = state.flick;
        const prev = { x: f.pos.x, y: f.pos.y };
        // 应用摩擦
        f.vel.x *= FRICTION;
        f.vel.y *= FRICTION;
        const speed = Math.hypot(f.vel.x, f.vel.y);
        // 位移
        f.pos.x += f.vel.x;
        f.pos.y += f.vel.y;
        // 边界限制
        f.pos = clampToCanvas(f.pos);
        f.points.push({ x: f.pos.x, y: f.pos.y });

        // 当有速度时，让攻击方飞机朝向与速度方向逐步对齐（速度感）
        const attackerSide = (f.plane.color === '#e74c3c') ? 0 : 1;
        const targetHeading = Math.atan2(f.vel.y, f.vel.x);
        f.plane.heading = f.plane.heading + (targetHeading - f.plane.heading) * 0.15;

        // 碰撞检测（当前段 prev->pos）
        tryHitEnemies(prev, f.pos, attackerSide);

        if (speed < MIN_SPEED) {
          // 停止：记录笔迹 & 更新飞机位置
          state.strokes.push({ points: f.points });
          f.plane.x = f.pos.x;
          f.plane.y = f.pos.y;
          state.flick = null;
          endTurn();
        }
      }

      requestAnimationFrame(step);
    }

    // 初始：显示菜单
    updateTurnHUD();
    uiLayer.style.display = 'grid';
    requestAnimationFrame(step);
  </script>
</body>
</html>
